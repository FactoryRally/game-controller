//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Tgm.Roborally.Client
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Net.Http;
	using Newtonsoft.Json;
	
	
	/// <summary>
	/// A tile is a square at the Game field<br>
	///**Note:** 
	///* `direction` is only aviable for belts
	///* properties with a `rotator-` prefix are only aviable for rotator (parts)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Tile
	{
		
		/// <summary>
		/// The type defines the function of a tile and how it is displayed. The behaviour is unknown to the client
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public TileType Type { get; set; }
		
		/// <summary>
		/// If there is no player at the tile this is true
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="empty")]
		public System.Nullable<System.Boolean> Empty { get; set; }
		
		/// <summary>
		/// Defines a direction in a 2D system. the X and Y values can be defined by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public TileDirection Direction { get; set; } = TileDirection.up;
		
		/// <summary>
		/// Defines wether to turn left or right
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rotator-direction")]
		public TileRotator_direction Rotator_direction { get; set; } = TileRotator_direction.left;
		
		/// <summary>
		/// The height of the tile. 1 = default
		/// Minimum: 1
		/// Maximum: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		[System.ComponentModel.DataAnnotations.Range(1, 3)]
		public System.Nullable<System.Int32> Level { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum TileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		normal = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rotator = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		wall = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		prio_core = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		conveyor = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="trap-door")]
		trap_door = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stomper = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		radioactive = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="repair site")]
		repair_site = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Button = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="One Way Wall")]
		One_Way_Wall = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Puddle = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pit = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Ramp = 13,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum TileDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		up = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		down = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		left = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		right = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum TileRotator_direction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		left = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		right = 1,
	}
	
	/// <summary>
	/// Defines a direction in a 2D system. the X and Y values can be defined by the client.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum Direction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		up = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		down = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		left = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		right = 3,
	}
	
	/// <summary>
	/// The rotator blocks consist of 4 blocks. This 4 blocks can be differenciated by this property
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum RotatorPosition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		up_left = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		up_right = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		down_left = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		down_right = 3,
	}
	
	/// <summary>
	/// Defines wether to turn left or right
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum Rotation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		left = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		right = 1,
	}
	
	/// <summary>
	/// Describes a actor at the game board. Not to be confused with `Player` which is the person controlling the Entity.
	///<br>
	///this will *most likely* be a player controlled robot but it also can be a AI controlled Entity or robot
	///> We did use Entity instead of the word Robot or bot because the word *bot* is used for the AIs controlling the robot. And also because theoretial a entity can be a not robot entity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Entity
	{
		
		/// <summary>
		/// Defines a direction in a 2D system. the X and Y values can be defined by the client.
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public TileDirection Direction { get; set; } = TileDirection.up;
		
		/// <summary>
		/// The default rule for names in the game
		/// Max length: 13
		/// Min length: 3
		/// Pattern: [A-Za-z]+[A-Za-z0-9 _- ]+[A-Za-z0-9]{1}
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.StringLength(13, MinimumLength=3)]
		public string Name { get; set; }
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Describes a point in a 2D system, without decimals
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Position Location { get; set; }
	}
	
	/// <summary>
	/// Describes a point in a 2D system, without decimals
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Position
	{
		
		/// <summary>
		/// The X cordinate
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="x")]
		public int X { get; set; }
		
		/// <summary>
		/// Position on the Y axis (top-down on screen)
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="y")]
		public int Y { get; set; }
	}
	
	/// <summary>
	/// Game Rules define the rules for a Game
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class GameRules
	{
		
		/// <summary>
		/// If true players can see the name of the player controlling a robot
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player-names-visible")]
		public System.Nullable<System.Boolean> Player_names_visible { get; set; }
		
		/// <summary>
		/// The maximum ammount of players able to join the game
		/// Minimum: 1
		/// Maximum: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max-players")]
		[System.ComponentModel.DataAnnotations.Range(1, 10)]
		public System.Nullable<System.Int32> Max_players { get; set; }
		
		/// <summary>
		/// The visible name of the game
		/// Max length: 50
		/// Min length: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength=3)]
		public string Name { get; set; }
		
		/// <summary>
		/// Defines the number of robots per player
		/// Minimum: 1
		/// Maximum: 3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="robots-per-player")]
		[System.ComponentModel.DataAnnotations.Range(1, 3)]
		public System.Nullable<System.Int32> Robots_per_player { get; set; }
		
		/// <summary>
		/// The password of a game
		/// Max length: 18
		/// Min length: 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		[System.ComponentModel.DataAnnotations.StringLength(18, MinimumLength=4)]
		public string Password { get; set; }
		
		/// <summary>
		/// If true emply player slots are going to be filled up with AI enemys
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fill-with-bots")]
		public System.Nullable<System.Boolean> Fill_with_bots { get; set; }
	}
	
	/// <summary>
	/// A Game is like a lobby, people can join/leave.<br>
	///A Game is created by a host who does *not* needs to attend the game as a player but in the most cases he will.
	///This is *read-only*
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Game
	{
		
		/// <summary>
		/// **Unique**<br>
		///This is the parameter a game is identified by
		/// Minimum: 0
		/// Maximum: 2048
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, 2048)]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// The name is **unique** but it should ***not*** be used as identifer (it's not natively supportet)
		///It is used to display the game's name
		/// Max length: 20
		/// Min length: 3
		/// Pattern: [A-Za-z]+[A-Za-z0-9 _-]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.StringLength(20, MinimumLength=3)]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of players attending the game.
		///(Only contains the name of the players)
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="players")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public int[] Players { get; set; }
		
		/// <summary>
		/// The phase the game is currently in
		///* `Lobby`: Players are able to join, Bots able to be added. Host can decide to start the game and leave the phase
		///* `Planning`: **[BETA - Not in game]** Players can choose their type of robot/bots bots autopick
		///* `Playing`: The game is running and the players can do interactions
		///* `Break`: The game is paused by the host. Players can still do interactions but they wont be executed as long as the break lasts
		///* `Finished` : The game is over and there is a winner. This is the time to save the game for a replay
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime_info")]
		public GameRuntime_info Runtime_info { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum GameRuntime_info
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOBBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLANNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLAYING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINISHED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BREAK = 4,
	}
	
	/// <summary>
	/// Describes the current state of the game. It does not includes the gamedata (like players/poitions/field) but general information.
	///
	///This is read only
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class GameInfo
	{
		
		/// <summary>
		/// The time passed since the game started in secconds. If the game is not started it will be `0`
		/// Minimum: -1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="passed-time")]
		[System.ComponentModel.DataAnnotations.Range(-1, System.Int32.MaxValue)]
		public int Passed_time { get; set; } = -1;
		
		/// <summary>
		/// The phase the game is currently in
		///* `Lobby`: Players are able to join, Bots able to be added. Host can decide to start the game and leave the phase
		///* `Planning`: **[BETA - Not in game]** Players can choose their type of robot/bots bots autopick
		///* `Playing`: The game is running and the players can do interactions
		///* `Break`: The game is paused by the host. Players can still do interactions but they wont be executed as long as the break lasts
		///* `Finished` : The game is over and there is a winner. This is the time to save the game for a replay
		///
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GameRuntime_info State { get; set; }
		
		/// <summary>
		/// Not every game can be connected to hardware (for example to many bots)
		///
		///If this is true it means you can use this game with hardware
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hardware-compatible")]
		public bool Hardware_compatible { get; set; } = false;
		
		/// <summary>
		/// Is a hardware boead connected
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hardware-attached")]
		public bool Hardware_attached { get; set; } = false;
		
		/// <summary>
		/// This id uniquely identifys the player (in a game).
		///
		/// **Not** to be confused with the `uid` which is used for authentication
		/// Minimum: 0
		/// Maximum: 8
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="player-on-turn")]
		[System.ComponentModel.DataAnnotations.Range(0, 8)]
		public int Player_on_turn { get; set; }
	}
	
	/// <summary>
	/// The phase the game is currently in
	///* `Lobby`: Players are able to join, Bots able to be added. Host can decide to start the game and leave the phase
	///* `Planning`: **[BETA - Not in game]** Players can choose their type of robot/bots bots autopick
	///* `Playing`: The game is running and the players can do interactions
	///* `Break`: The game is paused by the host. Players can still do interactions but they wont be executed as long as the break lasts
	///* `Finished` : The game is over and there is a winner. This is the time to save the game for a replay
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum GameState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOBBY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLANNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PLAYING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINISHED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BREAK = 4,
	}
	
	/// <summary>
	/// A message about that went wrong. Usefull to display users a short and usefull prompt
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Error_Message
	{
		
		/// <summary>
		/// A short message describing what happened in human words
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The error/exception
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
	}
	
	/// <summary>
	/// A queued action.
	///Actions are executed in their adding sequence which is represented by their index
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Action
	{
		
		/// <summary>
		/// The queue index of the action
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Int32> Index { get; set; }
		
		/// <summary>
		/// Defines what an action will do
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ActionType Type { get; set; }
		
		/// <summary>
		/// true if the action was allready executed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executed")]
		public System.Nullable<System.Boolean> Executed { get; set; }
		
		/// <summary>
		/// The index of the player this instruction came from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestor")]
		public System.Nullable<System.Int32> Requestor { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum ActionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAUSE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNPAUSE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		START_GAME = 2,
	}
	
	/// <summary>
	/// A round consits of 3 Phases each phase does different things
	///* `Upgrade` : Purchase Upgrades with energy cubes
	///* `Programming` : Programm your robot(s)
	///* `Activation` : The robots execute their code
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum RoundPhase
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		upgrade = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		programming = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		activation = 2,
	}
	
	/// <summary>
	/// A shop to buy upgrades from. Each element is buyable once and then vanishes from the list
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class UpgradeShop
	{
		
		/// <summary>
		/// Minimum items: 3
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgrades")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public int[] Upgrades { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="information")]
		public UpgradeShopInformation Information { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class UpgradeShopInformation
	{
		
		/// <summary>
		/// if true you can buy uprades
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="open")]
		public System.Nullable<System.Boolean> Open { get; set; }
	}
	
	/// <summary>
	/// A upgrade is a module making a robot stronger
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Upgrade
	{
		
		/// <summary>
		/// The energy cost to buy this upgrade
		/// Minimum: 0
		/// Maximum: 5
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cost")]
		[System.ComponentModel.DataAnnotations.Range(0, 5)]
		public int Cost { get; set; } = 2;
		
		/// <summary>
		/// The ame to display for this Upgrade. ***Not*** unique (identifying)
		/// Max length: 27
		/// Min length: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.StringLength(27, MinimumLength=2)]
		public string Name { get; set; }
		
		/// <summary>
		/// if true the card belongs to the player for the rest of the game
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permanent")]
		public System.Nullable<System.Boolean> Permanent { get; set; }
		
		/// <summary>
		/// A description about the effect of the card.
		///Variables are using the format `{name}` where *name* refers to the names in `values`. 
		/// Max length: 300
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.StringLength(300)]
		public string Description { get; set; }
		
		/// <summary>
		/// If the Upgrade is not permanent this variable defines the number of rounds this Upgrade works
		/// Minimum: 1
		/// Maximum: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rounds")]
		[System.ComponentModel.DataAnnotations.Range(1, 10)]
		public System.Nullable<System.Int32> Rounds { get; set; }
		
		/// <summary>
		/// Defines number values for the upgrade.<br>Example:
		///Effect: "You have {registers} additonal Registers"<br> `{registers}` is the number of the regsiters (that will be added) and the exact value will be defined in here (`values`)
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public Pair[] Values { get; set; }
		
		/// <summary>
		/// Defines the type (the code/actions) this card will have
		///* `generator` : Generates *x* energy every round
		/// Max length: 300
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		[System.ComponentModel.DataAnnotations.StringLength(300)]
		public UpgradeType Type { get; set; }
		
		/// <summary>
		/// The id of an upgrade. **Unique**
		/// Minimum: 0
		/// Maximum: 10000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, 10000)]
		public System.Nullable<System.Int32> Id { get; set; }
	}
	
	/// <summary>
	/// A named value. A pair of an index and value. (Part of a map)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Pair
	{
		
		/// <summary>
		/// The name the value is bound to
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.StringLength(int.MaxValue, MinimumLength=1)]
		public string Name { get; set; }
		
		/// <summary>
		/// The value behind the name. Can be null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Int32> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum UpgradeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		generator = 0,
	}
	
	/// <summary>
	/// A command for a robot to execute
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class RobotCommand
	{
		
		/// <summary>
		/// Defines what a command will do
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public RobotCommandType Type { get; set; }
		
		/// <summary>
		/// Defines parameters for the instruction.<br>Example:
		///Effect: "Move {steps} steps forward"<br> `{steps}` is the number of steps the robot will do. And the exact value (of steps) will be defined in here (`values`)
		/// Maximum items: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public Pair[] Parameters { get; set; }
		
		/// <summary>
		/// A description about the effect of the command.
		///Variables are using the format `{name}` where *name* refers to the names in `values`. 
		/// Max length: 300
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.StringLength(300)]
		public string Description { get; set; }
		
		/// <summary>
		/// The ame to display for this Command. ***Not*** unique (identifying)
		/// Max length: 27
		/// Min length: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.StringLength(27, MinimumLength=2)]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes how often this command is going to be executed
		/// Minimum: 1
		/// Maximum: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="times")]
		[System.ComponentModel.DataAnnotations.Range(1, 10)]
		public System.Nullable<System.Int32> Times { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum RobotCommandType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		move = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rotate = 1,
	}
	
	/// <summary>
	/// Defines what a command will do
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum Instruction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		move = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rotate = 1,
	}
	
	/// <summary>
	/// A player attending in a game.
	///#### Warning
	///This is **not** permanent. It is created and removed with the game (or with you joining and leaving the game)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Player
	{
		
		/// <summary>
		/// This id uniquely identifys the player (in a game).
		///
		/// **Not** to be confused with the `uid` which is used for authentication
		/// Minimum: 0
		/// Maximum: 8
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, 8)]
		public int Id { get; set; }
		
		/// <summary>
		/// The list of entities controlled by this player
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="controlled_entities")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public int[] Controlled_entities { get; set; }
		
		/// <summary>
		/// Îf this is true rhe player is able to interact at the moment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="on-turn")]
		public System.Nullable<System.Boolean> On_turn { get; set; }
		
		/// <summary>
		/// Defines if the player is actively playing. If this is false the player does random moves. This is only false if the player disconnects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
	}
	
	/// <summary>
	/// ## BETA (Adressed in V0.1.2)
	///A replay consists of all data needed to replay a game. Means starting conditions and every change that was made
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Replay
	{
	}
	
	/// <summary>
	/// All the data you need as you joined a game.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class JoinResponse
	{
		
		/// <summary>
		/// This id uniquely identifys the player (in a game).
		///
		/// **Not** to be confused with the `uid` which is used for authentication
		/// Minimum: 0
		/// Maximum: 8
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		[System.ComponentModel.DataAnnotations.Range(0, 8)]
		public int Id { get; set; }
		
		/// <summary>
		/// The uid is the key for the joined player. You need this key for authentication
		/// Minimum: 9999
		/// Maximum: 99999999
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pat")]
		[System.ComponentModel.DataAnnotations.Range(9999, 99999999)]
		public int Pat { get; set; }
	}
	
	/// <summary>
	/// Describes what the event is about
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum EventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movement = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="upgrade purchase")]
		upgrade_purchase = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fill register")]
		fill_register = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="activate upgrade")]
		activate_upgrade = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lazer shot")]
		lazer_shot = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="game start")]
		game_start = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="clear shop")]
		clear_shop = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fill shop")]
		fill_shop = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="register clear")]
		register_clear = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="programming timer start")]
		programming_timer_start = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="programming timer stop")]
		programming_timer_stop = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="random card distribution")]
		random_card_distribution = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="take card event")]
		take_card_event = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="activate checkpoint")]
		activate_checkpoint = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		game_phase_changed = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		game_round_phase_changed = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pause = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unpause = 17,
	}
	
	/// <summary>
	/// Describes the movement of a entity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class MovementEvent
	{
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Entity { get; set; }
		
		/// <summary>
		/// Defines a direction in a 2D system. the X and Y values can be defined by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public TileDirection Direction { get; set; } = TileDirection.up;
		
		/// <summary>
		/// How far (in tiles) the movement was executed
		/// Minimum: 0
		/// Maximum: 50
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="movement-ammount")]
		[System.ComponentModel.DataAnnotations.Range(0, 50)]
		public System.Nullable<System.Int32> Movement_ammount { get; set; }
		
		/// <summary>
		/// Defines wether to turn left or right
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rotation")]
		public TileRotator_direction Rotation { get; set; } = TileRotator_direction.left;
		
		/// <summary>
		/// The number of times (90°) the robot turns
		/// Minimum: 0
		/// Maximum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rotation-times")]
		[System.ComponentModel.DataAnnotations.Range(0, 2)]
		public System.Nullable<System.Int32> Rotation_times { get; set; }
		
		/// <summary>
		/// Describes a point in a 2D system, without decimals
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public Position From { get; set; }
		
		/// <summary>
		/// Describes a point in a 2D system, without decimals
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public Position To { get; set; }
	}
	
	/// <summary>
	/// Describes the map *without* the tiles
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class MapInfo
	{
		
		/// <summary>
		/// Minimum: 4
		/// Maximum: 500
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		[System.ComponentModel.DataAnnotations.Range(4, 500)]
		public System.Nullable<System.Int32> Width { get; set; }
		
		/// <summary>
		/// Minimum: 4
		/// Maximum: 500
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		[System.ComponentModel.DataAnnotations.Range(4, 500)]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Describes a point in a 2D system, without decimals
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prioBeacon")]
		public Position PrioBeacon { get; set; }
		
		/// <summary>
		/// The default rule for names in the game
		/// Max length: 13
		/// Min length: 3
		/// Pattern: [A-Za-z]+[A-Za-z0-9 _- ]+[A-Za-z0-9]{1}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.StringLength(13, MinimumLength=3)]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// When entities push each other
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class PushEvent
	{
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pusher-id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Pusher_id { get; set; }
		
		/// <summary>
		/// The number of tiles the pushed entity is pushed
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ammount")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Ammount { get; set; }
		
		/// <summary>
		/// Defines a direction in a 2D system. the X and Y values can be defined by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="push-directon")]
		public TileDirection Push_directon { get; set; } = TileDirection.up;
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pushed-id")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Pushed_id { get; set; }
	}
	
	/// <summary>
	/// Event if a player shoots a lazer
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class ShootEvent
	{
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shooter")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Shooter { get; set; }
		
		/// <summary>
		/// Defines a direction in a 2D system. the X and Y values can be defined by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public TileDirection Direction { get; set; } = TileDirection.up;
		
		/// <summary>
		/// Describes a point in a 2D system, without decimals
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public Position To { get; set; }
		
		/// <summary>
		/// The entitys hit by the ray
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hit-entitys")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public int[] Hit_entitys { get; set; }
	}
	
	/// <summary>
	/// Happens when a entity takes damage
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class DamageEvent
	{
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Entity { get; set; }
		
		/// <summary>
		/// The number of damage points
		/// Minimum: 0
		/// Maximum: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ammount")]
		[System.ComponentModel.DataAnnotations.Range(0, 5)]
		public System.Nullable<System.Int32> Ammount { get; set; }
	}
	
	/// <summary>
	/// The event that occurs if the active map elements are activated
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum MapEventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lazer = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rotator = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="conveyor-belts")]
		conveyor_belts = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stomper = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hole = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hole-trap")]
		hole_trap = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pusher = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		flamethrower = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		portal = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="toggle-ramps")]
		toggle_ramps = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		repair = 10,
	}
	
	/// <summary>
	/// Events that takes place with the active components of the map
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class MapEvent
	{
		
		/// <summary>
		/// The event that occurs if the active map elements are activated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public MapEventType Type { get; set; }
	}
	
	/// <summary>
	/// Called when a player is hit by an 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class LazerHitEvent
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// When a robot reboots
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class ShutdownEvent
	{
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entity")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Entity { get; set; }
	}
	
	/// <summary>
	/// The base type for entity actions between registers
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class EntityAction
	{
		
		/// <summary>
		/// The moment at which a entity action can be performed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phase")]
		public EntityActionPhase Phase { get; set; }
		
		/// <summary>
		/// Defines the action itsselft (what the action is doing)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public EntityActionType Type { get; set; } = EntityActionType.none;
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum EntityActionPhase
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pre_register = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		after_register = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum EntityActionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reboot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="use upgrade")]
		use_upgrade = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		spider_jump = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cache = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="register-refresh")]
		register_refresh = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="storage-swap")]
		storage_swap = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		jumper = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		teleporter = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="magnet-ray")]
		magnet_ray = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pushray = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rotation = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sidekick = 11,
	}
	
	/// <summary>
	/// The oportunity to perfom an action / event
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class EntityEventOportunity
	{
		
		/// <summary>
		/// Defines the action itsselft (what the action is doing)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public EntityEventOportunityType Type { get; set; } = EntityEventOportunityType.none;
		
		/// <summary>
		/// The time in ms left to do this action
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time-left")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> Time_left { get; set; }
		
		/// <summary>
		/// The in most languages avinable system time in MS as of which the action cant be committed any more
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end-time")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int64.MaxValue)]
		public System.Nullable<System.Int64> End_time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum EntityEventOportunityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reboot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="use upgrade")]
		use_upgrade = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		spider_jump = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Cache = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="register-refresh")]
		register_refresh = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="storage-swap")]
		storage_swap = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		jumper = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		teleporter = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="magnet-ray")]
		magnet_ray = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pushray = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rotation = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sidekick = 11,
	}
	
	/// <summary>
	/// type is allways `use-upgrade`
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class SimpleUpgradeActivation : EntityAction
	{
		
		/// <summary>
		/// The id of an upgrade. **Unique**
		/// Minimum: 0
		/// Maximum: 10000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgrade")]
		[System.ComponentModel.DataAnnotations.Range(0, 10000)]
		public System.Nullable<System.Int32> Upgrade { get; set; }
	}
	
	/// <summary>
	/// The action to make an entity use an upgade card (including the actions which require additional information)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class EntityUseUpgradeAction : EntityAction
	{
		
		/// <summary>
		/// The id of an upgrade. **Unique**
		/// Minimum: 0
		/// Maximum: 10000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgrade")]
		[System.ComponentModel.DataAnnotations.Range(0, 10000)]
		public System.Nullable<System.Int32> Upgrade { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum Robots
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dicer = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tank = 1,
	}
	
	/// <summary>
	/// Describes the state/stats of a robot
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class RobotInfo : Entity
	{
		
		/// <summary>
		/// The number of avainable energy cubes
		/// Minimum: 0
		/// Maximum: 20
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="energy-cubes")]
		[System.ComponentModel.DataAnnotations.Range(0, 20)]
		public System.Nullable<System.Int32> Energy_cubes { get; set; }
		
		/// <summary>
		/// The remaining health points
		/// Minimum: 1
		/// Maximum: 10
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health")]
		[System.ComponentModel.DataAnnotations.Range(1, 10)]
		public System.Nullable<System.Int32> Health { get; set; }
		
		/// <summary>
		/// True if the robot is not in rebooting mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// If the robot is in virtual mode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtual")]
		public System.Nullable<System.Boolean> Virtual { get; set; }
		
		/// <summary>
		/// The priority of this player. Higher is more priority. 1 = lowest. max = number of players
		/// Minimum: 1
		/// Maximum: 8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		[System.ComponentModel.DataAnnotations.Range(1, 8)]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// True if the robot is currently active (executing a register)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="on-turn")]
		public System.Nullable<System.Boolean> On_turn { get; set; }
		
		/// <summary>
		/// True if you are the one controlling the robot
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="is-mine")]
		public System.Nullable<System.Boolean> Is_mine { get; set; }
		
		/// <summary>
		/// The cards in the hand of the robot
		/// Minimum: 0
		/// Maximum: 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hand-cards")]
		[System.ComponentModel.DataAnnotations.Range(0, 9)]
		public System.Nullable<System.Int32> Hand_cards { get; set; }
		
		/// <summary>
		/// The height level of the robot
		/// Minimum: 0
		/// Maximum: 4
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attitude")]
		[System.ComponentModel.DataAnnotations.Range(0, 4)]
		public System.Nullable<System.Int32> Attitude { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Robots Type { get; set; }
	}
	
	public class Checkpoint
	{
	}
	
	/// <summary>
	/// Triggered when a robot is assigned to a player
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class RobotPickEvent
	{
		
		/// <summary>
		/// This id uniquely identifys the player (in a game).
		///
		/// **Not** to be confused with the `uid` which is used for authentication
		/// Minimum: 0
		/// Maximum: 8
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player")]
		[System.ComponentModel.DataAnnotations.Range(0, 8)]
		public System.Nullable<System.Int32> Player { get; set; }
		
		/// <summary>
		/// The unique identification of this entity. <br>
		///*!!!* This is not the id of the player<br>
		///This value will be autogenerated by the api and is read only
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="robot")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Robot { get; set; }
	}
	
	/// <summary>
	/// The map including the tiles
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class Map
	{
		
		/// <summary>
		/// Describes the map *without* the tiles
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="info")]
		public MapInfo Info { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rows")]
		public string[] Rows { get; set; }
	}
	
	/// <summary>
	/// When the next game phase started
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class GamePhaseChangeEvent
	{
		
		/// <summary>
		/// The phase the game is currently in
		///* `Lobby`: Players are able to join, Bots able to be added. Host can decide to start the game and leave the phase
		///* `Planning`: **[BETA - Not in game]** Players can choose their type of robot/bots bots autopick
		///* `Playing`: The game is running and the players can do interactions
		///* `Break`: The game is paused by the host. Players can still do interactions but they wont be executed as long as the break lasts
		///* `Finished` : The game is over and there is a winner. This is the time to save the game for a replay
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="new status")]
		public GameRuntime_info New_status { get; set; }
	}
	
	/// <summary>
	/// Used to store any event and generalize them into a single type
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class GenericEvent
	{
		
		/// <summary>
		/// Describes what the event is about
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public GenericEventType Type { get; set; }
		
		/// <summary>
		/// This is the data for the Event. In the case of type beeing `lazer hit`, data will be of the type `LazerHitEvent`. So the object-type allways matches to the `type` field 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum GenericEventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movement = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="upgrade purchase")]
		upgrade_purchase = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fill register")]
		fill_register = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="activate upgrade")]
		activate_upgrade = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lazer shot")]
		lazer_shot = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="game start")]
		game_start = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="clear shop")]
		clear_shop = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fill shop")]
		fill_shop = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="register clear")]
		register_clear = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="programming timer start")]
		programming_timer_start = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="programming timer stop")]
		programming_timer_stop = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="random card distribution")]
		random_card_distribution = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="take card event")]
		take_card_event = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="activate checkpoint")]
		activate_checkpoint = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		game_phase_changed = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		game_round_phase_changed = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pause = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unpause = 17,
	}
	
	/// <summary>
	/// Describes the event when the game is paused or unpaused
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class PauseEvent
	{
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public PauseEventState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public enum PauseEventState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNPAUSE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAUSE = 1,
	}
	
	/// <summary>
	/// Describes an event from an action without additionaly information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://localhost:5050/")]
	public class ActionEvent
	{
	}
	
	public partial class RoborallyClient
	{
		
		private System.Net.Http.HttpClient client;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public RoborallyClient(System.Net.Http.HttpClient client, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (client == null)
				throw new ArgumentNullException("Null HttpClient.", "client");

			if (client.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "client");

			this.client = client;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get all games
		/// Returns a list of all hosted games
		/// GetGames games/
		/// </summary>
		/// <param name="joinable">true: only return joinable games</param>
		/// <param name="unprotected">true: only display games with no password set</param>
		/// <returns>OK</returns>
		public async Task<int[]> GetGamesAsync(bool joinable, bool unprotected, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/?joinable="+joinable+"&unprotected="+unprotected;
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<int[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create Game
		/// Creates a random game by your defined rules
		/// CreateGame games/
		/// </summary>
		/// <param name="requestBody">*Optional*
		///This rules define how your game will behave</param>
		/// <returns>OK</returns>
		public async Task CreateGameAsync(GameRules requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get game status
		/// Returns the status of a game
		/// GetGameState games/{game_id}/status
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GameInfo> GetGameStateAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/status";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GameInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get games actions
		/// Get all (**not robot related**) actions comitted to this game.
		/// GetActions games/{game_id}/actions
		/// </summary>
		/// <param name="mode">Defines wich entries to return</param>
		/// <returns>OK</returns>
		public async Task<Action[]> GetActionsAsync(GetActionsMode mode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/actions?mode=" + mode;
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Action[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Commit Action
		/// Queues an action to be executed
		/// CommitAction games/{game_id}/actions
		/// </summary>
		/// <returns>OK</returns>
		public async Task CommitActionAsync(ActionType action, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/actions?action=" + action;
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Put, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all players
		/// Returns the index of all players
		/// GetAllPlayers games/{game_id}/players/
		/// </summary>
		/// <returns>OK</returns>
		public async Task<int[]> GetAllPlayersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/players/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<int[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Join game
		/// Join the given game.
		/// You will get your ID by doing this, if you already in the game you can get your ID again if you lost it.<br>
		/// The id is neccessary for any further API calls
		/// Join games/{game_id}/players/
		/// </summary>
		/// <param name="password">The password of the game if the lobby is password protected</param>
		/// <returns>Joined</returns>
		public async Task<JoinResponse> JoinAsync(string password, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/players/?password=" + (password==null? "" : Uri.EscapeDataString(password));
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<JoinResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get player
		/// Get closer information about the player
		/// GetPlayer games/{game_id}/players/{player_id}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Player> GetPlayerAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/players/{player_id}";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Player>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove Player
		/// Removes a player from the game. This can be done by the player itsself or by the host.
		/// KickPlayer games/{game_id}/players/{player_id}
		/// </summary>
		/// <returns>OK</returns>
		public async Task KickPlayerAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/players/{player_id}";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set Robots
		/// # DEPRECATET
		/// > This feature is useless in this version. It will be usefull in newer versions
		/// 
		/// Sets the type of robot(s) the player is controlling
		/// ChooseRobot games/{game_id}/players/{player_id}
		/// </summary>
		/// <param name="requestBody">The robots assigned to the player</param>
		/// <returns>OK</returns>
		public async Task ChooseRobotAsync(Robots[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/players/{player_id}";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get upgrade shop
		/// Retuns a list of all cards in the upgrade shop
		/// GetUpgradeShop games/{game_id}/upgrades/shop
		/// </summary>
		/// <returns>OK</returns>
		public async Task<UpgradeShop> GetUpgradeShopAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/upgrades/shop";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<UpgradeShop>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Buy Upgrade
		/// Buy this Upgrade from the shop.
		/// ### Note
		/// If your robot allready owns 3 Upgrades you have to use the `exchange` parameter. This is the ID of the Upgrade to replace with the bought one
		/// BuyUpgrade games/{game_id}/upgrades/shop
		/// </summary>
		/// <returns>OK</returns>
		public async Task BuyUpgradeAsync(int upgrade, int exchange, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/upgrades/shop?upgrade="+upgrade+"&exchange="+exchange;
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get upgrade information
		/// Get detailed information about the Upgrade
		/// GetUpgradeInformation games/{game_id}/upgrades/{upgrade_id}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Upgrade> GetUpgradeInformationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/upgrades/{upgrade_id}";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Upgrade>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// get all Upgrades
		/// Returns a list of all Upgrade IDs
		/// GetAllUpgradeIDs games/{game_id}/upgrades/
		/// </summary>
		/// <returns>OK</returns>
		public async Task<int[]> GetAllUpgradeIDsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/upgrades/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<int[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get register information
		/// Returns the content of the registers
		/// GetRegisters games/{game_id}/entitys/robots/{robot_id}/registers
		/// </summary>
		/// <returns>OK</returns>
		public async Task<RobotCommand[]> GetRegistersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/registers";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RobotCommand[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// change register content
		/// Updates the card in a register
		/// UpdateRegister games/{game_id}/entitys/robots/{robot_id}/registers
		/// </summary>
		/// <returns>OK</returns>
		public async Task UpdateRegisterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/registers";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// clear registers
		/// Emptys all register of the robot
		/// ClearRegisters games/{game_id}/entitys/robots/{robot_id}/registers
		/// </summary>
		/// <returns>OK</returns>
		public async Task ClearRegistersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/registers";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Robot Upgrades
		/// Returns the upgrades installed on the robot
		/// GetInstalledUpgrades games/{game_id}/entitys/robots/{robot_id}/upgrades
		/// </summary>
		/// <returns>OK</returns>
		public async Task<int[]> GetInstalledUpgradesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/upgrades";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<int[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Clear Robot Upgrades
		/// Removes all upgrades from a robot
		/// ClearUpgrades games/{game_id}/entitys/robots/{robot_id}/upgrades
		/// </summary>
		/// <returns>OK</returns>
		public async Task ClearUpgradesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/upgrades";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove Upgrade
		/// Removes a paticular upgrade from the robot
		/// RemoveRobotUpgrade games/{game_id}/entitys/robots/{robot_id}/upgrades
		/// </summary>
		/// <returns>OK</returns>
		public async Task RemoveRobotUpgradeAsync(int upgrade, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/upgrades?upgrade="+upgrade;
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Patch, requestUri))
			{
			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get tile
		/// Inspect a tile of the map
		/// GetTile games/{game_id}/map/tiles/{x}/{y}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Tile> GetTileAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/map/tiles/{x}/{y}";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Tile>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Map info
		/// Get meta information abouzt the map of the game
		/// GetMapInfo games/{game_id}/map/info
		/// </summary>
		/// <returns>OK</returns>
		public async Task<MapInfo> GetMapInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/map/info";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MapInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next / last movement event
		/// Returns the next unfetched event of the movement type.
		/// 
		/// If the event is not of the movement type you will get a `400` status and the event stays unfetched
		/// FetchNextMovementEvent games/{game_id}/events/movement
		/// </summary>
		/// <returns>OK</returns>
		public async Task<MovementEvent> FetchNextMovementEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/movement";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MovementEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next / last damage event
		/// Returns the next unfetched event of the damage type.
		/// 
		/// If the event is not of the damage type you will get a `400` status and the event stays unfetched
		/// FetchNextDamageEvent games/{game_id}/events/damage
		/// </summary>
		/// <returns>OK</returns>
		public async Task<DamageEvent> FetchNextDamageEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/damage";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<DamageEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next / last Lazer hit event
		/// Returns the next unfetched event of the lazer hit type.
		/// 
		/// If the event is not of the lazer hit type you will get a `400` status and the event stays unfetched
		/// FetchNextLazerHitEvent games/{game_id}/events/lazer-hit
		/// </summary>
		/// <returns>OK</returns>
		public async Task<LazerHitEvent> FetchNextLazerHitEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/lazer-hit";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<LazerHitEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next / last map event
		/// Returns the next unfetched event of the  Map Event type.
		/// Map Events activeata all active components of a type at once
		/// 
		/// If the event is not of the map event type you will get a `400` status and the event stays unfetched
		/// FetchNextMapEvent games/{game_id}/events/map
		/// </summary>
		/// <returns>OK</returns>
		public async Task<MapEvent> FetchNextMapEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/map";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MapEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next / last push event
		/// Returns the next unfetched event of the push type.
		/// 
		/// If the event is not of the push  type you will get a `400` status and the event stays unfetched
		/// FetchNextPushEvent games/{game_id}/events/push
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PushEvent> FetchNextPushEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/push";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<PushEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next / last shoot event
		/// Returns the next unfetched event of the movement type.
		/// 
		/// If the event is not of the movement type you will get a `400` status and the event stays unfetched
		/// FetchNextShootEvent games/{game_id}/events/shoot
		/// </summary>
		/// <returns>OK</returns>
		public async Task<ShootEvent> FetchNextShootEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/shoot";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ShootEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next / last shutdown event
		/// Returns the next unfetched event of the movement type.
		/// 
		/// If the event is not of the movement type you will get a `400` status and the event stays unfetched
		/// FetchNextShutdownEvent games/{game_id}/events/shutdown
		/// </summary>
		/// <returns>OK</returns>
		public async Task<ShutdownEvent> FetchNextShutdownEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/shutdown";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<ShutdownEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Map
		/// Returns the map of this specific game including the tiles (data)
		/// GetGameMap games/{game_id}/map
		/// </summary>
		/// <returns>OK</returns>
		public async Task<Map> GetGameMapAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/map";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<Map>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all robots
		/// Returns a list of all robot IDs in this game.
		/// > A robot is not a player as a player is able to controll multiple robots
		/// GetRobots games/{game_id}/entitys/robots/
		/// </summary>
		/// <returns>OK</returns>
		public async Task<int[]> GetRobotsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<int[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Aviable actions
		/// Returns a list of EntityActionTypes which are possible to be executed at the moment.
		/// GetPossibleActions games/{game_id}/entitys/robots/{robot_id}/actions/avinable
		/// </summary>
		/// <returns>OK</returns>
		public async Task<EntityEventOportunity[]> GetPossibleActionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/actions/avinable";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EntityEventOportunity[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add Entity Action to stack
		/// Adds an action to the stack. The stack is processed using *first in first out*
		/// DoEntityAction games/{game_id}/entitys/robots/{robot_id}/actions/stack/
		/// </summary>
		/// <returns>OK</returns>
		public async Task DoEntityActionAsync(EntityAction requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/actions/stack/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Robot action stack
		/// Retuns a list od all actions in the stack
		/// GetActionStack games/{game_id}/entitys/robots/{robot_id}/actions/stack/
		/// </summary>
		/// <returns>OK</returns>
		public async Task<EntityAction[]> GetActionStackAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/actions/stack/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EntityAction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Robot Informations
		/// Returns the status and info about the robot
		/// GetRobotStats games/{game_id}/entitys/robots/{robot_id}/info
		/// </summary>
		/// <returns>OK</returns>
		public async Task<RobotInfo> GetRobotStatsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/entitys/robots/{robot_id}/info";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<RobotInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// trace event
		/// All events needed by the client are accessible here. (Usefull for animations)
		/// More about this function is found in the [regarding Github Issue](https://github.com/FactoryRally/game-controller/issues/6)
		/// 
		/// **This function only returns the type of the event you need to fetch the data seperately**
		/// > Read more at [api-usage.md](https://github.com/FactoryRally/game-controller/blob/master/documentation/rest/api-usage.md#events--updates)
		/// TraceEvent games/{game_id}/events/type
		/// </summary>
		/// <param name="batch">If true you will get all past events at once
		///If false the list only contains the oldest unfetched event</param>
		/// <param name="wait">If true the server will not responde until a event is added to the queue
		///
		///Rrequires less traffic but might impacts the servers performance or cause timeouts at the client</param>
		/// <returns>OK</returns>
		public async Task<EventType[]> TraceEventAsync(bool batch, bool wait, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/type?batch="+batch+"&wait="+wait;
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<EventType[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Map Names
		/// Returns a list of all map names
		/// GetMaps maps/
		/// </summary>
		/// <returns>OK</returns>
		public async Task<string[]> GetMapsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "maps/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Save Map
		/// Saves a map to the repository
		/// SaveMap maps/
		/// </summary>
		/// <param name="requestBody">The map to save</param>
		/// <returns>OK</returns>
		public async Task SaveMapAsync(Map requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "maps/";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get map
		/// Get a map by its name
		/// GetMap maps/{map_name}
		/// </summary>
		/// <returns>OK</returns>
		public async Task<MapInfo> GetMapAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "maps/{map_name}";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<MapInfo>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Map
		/// Delete a map by its name
		/// DeleteMap maps/{map_name}
		/// </summary>
		public async Task DeleteMapAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "maps/{map_name}";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next event
		/// Returns the next unfetched event of the ***any*** type.
		/// FetchNextEvent games/{game_id}/events/head
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GenericEvent> FetchNextEventAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/{game_id}/events/head";
			using (var httpRequestMessage = new HttpRequestMessage(HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await client.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCode();
				var stream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(stream)))
				{
				var serializer = new JsonSerializer();
				return serializer.Deserialize<GenericEvent>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum GetActionsMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 2,
	}
}
