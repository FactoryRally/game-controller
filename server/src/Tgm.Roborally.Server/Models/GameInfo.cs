/*
 * Robot Rally Game logic engine
 *
 * This api controlls the flow of a game and provides it's data. It is desiged to be RESTfull so the structure works simmilar as file system. The service will run and only work in a local network, `game.host` is the IP of the Computer hosting the game and will be found via a IP scan
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: nbrugger@student.tgm.ac.at
 * Generated by: https://openapi-generator.tech
 */

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Tgm.Roborally.Server.Converters;
using Tgm.Roborally.Server.Engine;

namespace Tgm.Roborally.Server.Models {
	/// <summary>
	/// Describes the current state of the game. It does not includes the gamedata (like players/poitions/field) but general information.  This is read only
	/// </summary>
	[DataContract]
	public partial class GameInfo : IEquatable<GameInfo> {
		private GameLogic _ref { get; }

		public GameInfo(GameLogic game) {
			_ref = game;
		}

		/// <summary>
		/// The time passed since the game started in secconds. If the game is not started it will be &#x60;0&#x60;
		/// </summary>
		/// <value>The time passed since the game started in secconds. If the game is not started it will be &#x60;0&#x60;</value>
		[Required]
		[DataMember(Name = "passed-time", EmitDefaultValue = true)]
		public int PassedTime { get; set; } = -1;

		/// <summary>
		/// Gets or Sets State
		/// </summary>
		[Required]
		[DataMember(Name = "state", EmitDefaultValue = true)]
		public GameState State => _ref.State;

		/// <summary>
		/// Not every game can be connected to hardware (for example to many bots)  If this is true it means you can use this game with hardware
		/// </summary>
		/// <value>Not every game can be connected to hardware (for example to many bots)  If this is true it means you can use this game with hardware</value>
		[Required]
		[DataMember(Name = "hardware-compatible", EmitDefaultValue = true)]
		public bool HardwareCompatible => _ref.Hardware.Compatible;

		/// <summary>
		/// Is a hardware boead connected
		/// </summary>
		/// <value>Is a hardware boead connected</value>
		[Required]
		[DataMember(Name = "hardware-attached", EmitDefaultValue = true)]
		public bool HardwareAttached => false;

		/// <summary>
		/// This id uniquely identifys the player (in a game).   **Not** to be confused with the &#x60;uid&#x60; which is used for authentication
		/// </summary>
		/// <value>This id uniquely identifys the player (in a game).   **Not** to be confused with the &#x60;uid&#x60; which is used for authentication</value>
		[Required]
		[Range(0, 8)]
		[DataMember(Name = "player-on-turn", EmitDefaultValue = true)]
		public int PlayerOnTurn => _ref.playerOnTurn;

		/// <summary>
		/// Returns the string presentation of the object
		/// </summary>
		/// <returns>String presentation of the object</returns>
		public override string ToString() {
			var sb = new StringBuilder();
			sb.Append("class GameInfo {\n");
			sb.Append("  PassedTime: ").Append(PassedTime).Append("\n");
			sb.Append("  State: ").Append(State).Append("\n");
			sb.Append("  HardwareCompatible: ").Append(HardwareCompatible).Append("\n");
			sb.Append("  HardwareAttached: ").Append(HardwareAttached).Append("\n");
			sb.Append("  PlayerOnTurn: ").Append(PlayerOnTurn).Append("\n");
			sb.Append("}\n");
			return sb.ToString();
		}

		/// <summary>
		/// Returns the JSON string presentation of the object
		/// </summary>
		/// <returns>JSON string presentation of the object</returns>
		public string ToJson() {
			return JsonConvert.SerializeObject(this, Formatting.Indented);
		}

		/// <summary>
		/// Returns true if objects are equal
		/// </summary>
		/// <param name="obj">Object to be compared</param>
		/// <returns>Boolean</returns>
		public override bool Equals(object obj) {
			if (obj is null) return false;
			if (ReferenceEquals(this, obj)) return true;
			return obj.GetType() == GetType() && Equals((GameInfo) obj);
		}

		/// <summary>
		/// Returns true if GameInfo instances are equal
		/// </summary>
		/// <param name="other">Instance of GameInfo to be compared</param>
		/// <returns>Boolean</returns>
		public bool Equals(GameInfo other) {
			if (other is null) return false;
			if (ReferenceEquals(this, other)) return true;

			return
				(
					PassedTime == other.PassedTime ||
					PassedTime.Equals(other.PassedTime)
				) &&
				(
					State == other.State ||
					State.Equals(other.State)
				) &&
				(
					HardwareCompatible == other.HardwareCompatible ||
					HardwareCompatible.Equals(other.HardwareCompatible)
				) &&
				(
					HardwareAttached == other.HardwareAttached ||
					HardwareAttached.Equals(other.HardwareAttached)
				) &&
				(
					PlayerOnTurn == other.PlayerOnTurn ||
					PlayerOnTurn.Equals(other.PlayerOnTurn)
				);
		}

		/// <summary>
		/// Gets the hash code
		/// </summary>
		/// <returns>Hash code</returns>
		public override int GetHashCode() {
			unchecked // Overflow is fine, just wrap
			{
				var hashCode = 41;
				// Suitable nullity checks etc, of course :)

				hashCode = hashCode * 59 + PassedTime.GetHashCode();

				hashCode = hashCode * 59 + State.GetHashCode();

				hashCode = hashCode * 59 + HardwareCompatible.GetHashCode();

				hashCode = hashCode * 59 + HardwareAttached.GetHashCode();

				hashCode = hashCode * 59 + PlayerOnTurn.GetHashCode();
				return hashCode;
			}
		}

		#region Operators

		#pragma warning disable 1591

		public static bool operator ==(GameInfo left, GameInfo right) {
			return Equals(left, right);
		}

		public static bool operator !=(GameInfo left, GameInfo right) {
			return !Equals(left, right);
		}

		#pragma warning restore 1591

		#endregion Operators
	}
}